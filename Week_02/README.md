## 写一个关于 HashMap 的小总结。

### Map

- HashTable

	- 不支持 null 键和值

- HashMap

	- 性能

		- 表现非常依赖于哈希码的有效性

			- hashCode 和 equals 的一些基本约定

				- equals 相等，hashCode 一定要相等
				- 重写了 hashCode 也要重写 equals
				- hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致
				- equals 的对称、反射、传递等特性

		- 常数级的 get()、put()

	- 非线程安全
	- 结构

		- 数组（Node[] table）和链表结合组成的复合结构

			- 哈希值相同的键值对，则以链表形式存储

		- 扩容

			- resize

				- 门限值 = （负载因子）* （容量）
				- 倍数进行调整
				- 性能开销

					- 将老的数组中的元素重新放置到新的数组

		- 哈希思想

			- 当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象
			- 当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象
			- 使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中

	- HashMap 源码分析

		- HashMap 内部实现基本点分析
		- 容量（capacity）和负载系数（load factor）

			-  负载因子 * 容量 > 元素数量

				- 容量 大于“预估元素数量 / 负载因子”，同时它是 2 的幂数
				- 默认的情况下，HashMap的容量是16

		- 树化

			- 为什么 HashMap 要树化呢？

				- 在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能
				- 本质上这是个性能-安全问题

			- 使用红黑树
			- 解决哈希冲突的常用方法

				- 开放定址法
				- 再哈希法
				- 链地址法
				- 建立公共溢出区

			- 如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构

	- LinkedHashMap

		- 双向链表头结点header 
		- 标志位accessOrder

- TreeMap

	- 构建一个具有优先级的调度系统

		- 优先队列

			- 基于二叉堆实现的 PriorityQueue

	- 工程应用

		- Fisp中登要求报文有 head-body-tail 的要求

	- 红黑树顺序访问

		- （树中的每个节点的值，都会大于或等于它的左子树种的所有节点的值，并且小于或等于它的右子树中的所有节点的值
		- 实现了SortMap<K,V>接口，对key进行了排序
		- 具体顺序可以由指定的 Comparator 来决定

	- O(log N)

*XMind - Trial Version*



## 两数之和
完成


## N 叉树的前、中、后序遍历

- 树的面试题解法一般都是递归，为什么？   

数据结构具有最小重复的特点



## HeapSort 

- 自学 https://www.geeksforgeeks.org/heap-sort/


## 学习经验

1. 最好的检验学习成果标准是教别人，比如教别人 快排 的实现过程